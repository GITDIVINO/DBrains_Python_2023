'''
1. На вход программе подается строка текста из натуральных чисел. Из неё формируется список чисел. Напишите программу подсчета количества чисел, 
которые больше предшествующего им в этом списке числа, то есть, стоят вслед за меньшим числом.

Формат входных данных
На вход программе подается строка текста из разделенных пробелами натуральных чисел.

Формат выходных данных
Программа должна вывести одно число – количество элементов списка, больших предыдущего.

Тестовые данные
Sample Input 1:
1 2 3 4 5
Sample Output 1:
4
Sample Input 2:
1 1 3 2 2 1 1 1 1
Sample Output 2:
1
Sample Input 3:
5 4 3 2 1
Sample Output 3:
0
'''

# def find_bigger(lst1):

#     lst2 = [int(i) for i in lst1.split()]
#     count = 0

#     for i in range(len(lst2)):
#         if i !=0:
#             if lst2[i] > lst2[i - 1]:
#                 count += 1
            
#     return count


# if __name__ == '__main__':
#     print(find_bigger('1 2 3 4 5'))
#     print(find_bigger('1 1 3 2 2 1 1 1 1'))
#     print(find_bigger('5 4 3 2 1'))
#     print(find_bigger(input('Введите натуральные числа через пробел: ')))

'''
2. На вход программе подается строка текста из натуральных чисел. Из элементов строки формируется список чисел. Напишите программу, которая меняет местами 
соседние элементы списка (a[0] c a[1], a[2] c a[3] и т.д.). Если в списке нечетное количество элементов, то последний остается на своем месте.

Формат входных данных
На вход программе подается строка текста, содержащая натуральные числа, разделенные пробелами.

Формат выходных данных
Программа должна вывести измененный список, разделяя его элементы одним пробелом.

Тестовые данные
Sample Input 1:
1 2 3 4 5
Sample Output 1:
2 1 4 3 5
Sample Input 2:
2 3 2 4
Sample Output 2:
3 2 4 2
Sample Input 3:
1
Sample Output 3:
1
'''

# def change_place(lst1):

#     lst2 = [int(i) for i in lst1.split()]
    
#     for i in range(0, len(lst2)-1, 2):
#         lst2[i], lst2[i+1] = lst2[i+1], lst2[i]
        
#     return lst2


# if __name__ == '__main__':
#     print(change_place('1 2 3 4 5'))
#     print(change_place('2 3 2 4'))
#     print(change_place('1'))


# !!! lst2 = list1(map(int, input().split))


'''
3. Вводится слово. Переменной msg присвоить строку "палиндром", если введенное слово является палиндромом (одинаково читается и вперед и назад), а иначе присвоить
строку "не палиндром". Проверку проводить без учета регистра. Программу реализовать с помощью тернарного условного оператора. Значение переменной msg отобразить 
на экране.

Sample Input:
Казак
Sample Output:
палиндром
'''

# def is_pal(word = input('Введите слово: ')):

#     word1 = word.lower()
#     word2 = word[::-1]

#     if word1 == word2:
#         msg = 'палиндром'
#     else:
#         msg = ' не палиндром'

#     return msg


# if __name__ == '__main__':
#     print(is_pal())

'''
4. Подвиг 7. Вводятся номера телефонов в одну строчку через пробел с разными кодами стран: +7, +6, +2, +4 и т.д. Необходимо составить словарь d, где ключи 
- это коды +7, +6, +2 и т.п., а значения - список номеров (следующих в том же порядке, что и во входной строке) с соответствующими кодами. Полученный словарь 
вывести командой:

print(*sorted(d.items()))

Sample Input:
+71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890
Sample Output:
('+2', ['+21235777890', '+21234567110']) ('+5', ['+52134567890']) ('+6', ['+61234576890']) ('+7', ['+71234567890', '+71234567854', '+71232267890'])
'''
# from collections import defaultdict

# def make_slov(text):

#     lst1 = text.split()
#     d = defaultdict(list)
    
#     for i in range(len(lst1)):
#         # d[lst1[i][:2]].append(lst1[i])
#         try:
#             d[lst1[i][:2]].append(lst1[i])
#         except KeyError:
#             d[lst1[i][:2]] = lst1[i]

#     return sorted(d.items())

# if __name__ == '__main__':
#     print(make_slov('+71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890'))

